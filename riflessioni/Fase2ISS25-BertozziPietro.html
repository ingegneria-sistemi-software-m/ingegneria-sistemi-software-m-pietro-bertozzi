<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
        crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
        crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="./commons/resources/styles/templateISS.css">
    <link rel="stylesheet" type="text/css" href="./commons/resources/styles/main.css">
    <link rel="stylesheet" type="text/css" href="./commons/resources/styles/navbar.css">
    <link rel="stylesheet" type="text/css" href="./commons/resources/styles/table.css">
    <link rel="stylesheet" type="text/css" href="./commons/resources/styles/code.css">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="marks.js"></script>
    <title>BertozziPietro</title>
</head>
<!--
		<body onload="loadNav();">
			<div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
			<div id="sidenav" class="sidenav">
				<a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
				<a href=".README.html">ReadMe</a>
				<a class="sprint" href="../../../Sprint0/Codice/userDocs/Cold%20Storage%20Service%20-%20Natali%20V3.html">Sprint0</a>
				<a class="sprint" href="../../../Sprint1.0/Codice/userDocs/Sprint%201.0%20-%20V3.html">Sprint1.0</a>
				<a class="sprint" href="../../../Sprint1.1/Codice/userDocs/Sprint%201.1%20-%20V3.html">Sprint1.1</a>
				<a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
				<div class="sidenavSection">
					<a href="#Goal Sprint 2">Goal Sprint 2</a>
					<a href="#Requisiti">Requisiti</a>
					<a href="#Analisi dei Requisiti">Analisi dei Requisiti</a>
					<a href="#Analisi del Problema">Analisi del Problema</a>
					<a href="#Test Plan">Test Plan</a>
					<a href="#Progettazione">Progettazione</a>
					<a href="#Deployment">Deployment</a>
				</div>
				<p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
				<a class="sprint" href="../../../Sprint3/Codice/userDoc/Sprint%203.html">Sprint3</a>
				<bottom-spacer/>
			</div>
	-->

<body>
    <div id="top">
        <h1>ELABORATO FASE B <font size="5"></font>
        </h1>
    </div>
    <div class="body">
        <div class="remark"
            style="background-color:rgba(86, 56, 253, 0.9); width:100%; text-align:left; color:white; display:flex; align-items:center; justify-content:space-between; padding:10px;">
            <div>
                <h3>Bertozzi Pietro</h3><br>
                E-mail istituzionale: <a href="mailto:pietro.bertozzi3@studio.unibo.it" style="color:white;"
                    target="_blank">pietro.bertozzi3@studio.unibo.it</a><br>
                GitHub organizzation gruppo progetto finale sito web: <a
                    href="https://ingegneria-sistemi-software-m.github.io" style="color:white;"
                    target="_blank">https://ingegneria-sistemi-software-m.github.io</a><br>
                GitHub organizzation gruppo progetto finale: <a href="https://github.com/ingegneria-sistemi-software-m"
                    style="color:white;" target="_blank">https://github.com/ingegneria-sistemi-software-m</a><br>
                GitHub repository personale: <a
                    href="https://github.com/ingegneria-sistemi-software-m/ingegneria-sistemi-software-m-pietro-bertozzi"
                    style="color:white;"
                    target="_blank">https://github.com/ingegneria-sistemi-software-m/ingegneria-sistemi-software-m-pietro-bertozzi</a><br>
                Diario principale: <a
                    href="https://github.com/ingegneria-sistemi-software-m/ingegneria-sistemi-software-m-pietro-bertozzi/tree/main/riflessioni"
                    style="color:white;"
                    target="_blank">https://github.com/ingegneria-sistemi-software-m/ingegneria-sistemi-software-m-pietro-bertozzi/tree/main/riflessioni</a><br>
            </div>
            <img src="./portrait.jpg" alt="errore immagine" width="15%" height="15%" style="border-radius: 15px;">
        </div>

        <div class="remark mark"
            style="background-color:black; width:100%; text-align:left; color:white; display:flex; align-items:center; justify-content:space-between; padding:10px;">
            <div style="flex: 1; padding-right: 20px;">
                <h3>Quello che lo scrivente ha percepito sia la finalità dei contenuti discussi in questa seconda fase,
                    e quello che lo scrivente si aspetta sia lo scopo della prossima fase del corso</h3>
                In questa seconda fase del corso ho colto come obiettivo principale l’introduzione e l’approfondimento
                del modello ad attori come paradigma di riferimento per progettare sistemi distribuiti. Rispetto a
                modelli più tradizionali, come quello a oggetti o event-driven, il modello ad attori mette in primo
                piano la nozione di entità autonome, in grado di gestire messaggi in modo indipendente e con logiche di
                comportamento legate al loro stato interno.<br>
                È un cambiamento di prospettiva che non riguarda solo la tecnica, ma anche il modo di pensare la
                progettazione.<br>
                Un altro aspetto centrale è stato quello legato alla relazione tra linguaggi e problemi: non basta saper
                risolvere un problema, è importante anche con quale livello di espressività e chiarezza si riesce a
                descriverlo. Da qui la riflessione sull’abstraction gap e su come strumenti come DSL (in particolare
                QAK, nel nostro caso) possano aiutare ad avvicinare la descrizione del sistema al modo in cui lo
                immaginiamo.<br>
                Per quanto riguarda la prossima fase, al solito, lascio che il professore mi sorprenda.<br>
            </div>
            <span style="font-size: 12vw; flex-shrink: 0; margin-left: 40px; margin-right: 40px">A-</span>
        </div>
        <div class="remark mark"
            style="background-color:black; width:100%; text-align:left; color:white; display:flex; align-items:center; justify-content:space-between; padding:10px;">
            <div style="flex: 1; padding-right: 20px;">
                <h3>Le nuove abilità / competenze che lo scrivente pensa di avere appreso (o che sia possibile
                    apprendere) dopo questa seconda fase, sia in relazione alla parte ‘pratica’ del saper-fare
                    (strumenti, tecnologie, etc.) sia con riferimento ad aspetti più ‘concettuali’ (metodologie,
                    modelli, etc.)</h3>
                Dal punto di vista pratico, in questa fase ho acquisito maggiore familiarità con il linguaggio QAK, che
                permette di descrivere un sistema distribuito in termini di attori, messaggi e contesti. Ho imparato a
                progettare e implementare sistemi composti da più attori, ognuno con il proprio comportamento reattivo,
                e a farli comunicare in modo ordinato e comprensibile.<br>
                Sul piano concettuale, ho consolidato una visione più matura della progettazione software. Ho capito che
                un modello non è solo un aiuto visivo o una documentazione, ma può (e deve) essere eseguibile: se un
                modello può essere compreso dalla macchina, allora è anche non ambiguo, preciso, e utile per il
                confronto. Ho riflettuto inoltre sull'importanza di scegliere il giusto metamodello in base al tipo di
                sistema da progettare: non sempre UML è la scelta migliore, e in alcuni contesti, come quelli trattati
                qui, un approccio basato su attori risulta decisamente più efficace.<br>
                Di fatto questo cambio di prospettiva apre moltisse possibilità e, appena avrò tempo di farlo, sudierò
                volentieri lo stato dell'arte a riguardo.<br>
                Sarò arrogante, ma ho l'impressione che sia un campo in cui è possibile innovare ulteriormente...
                devo/voglio studiare più approfonditamente la questione.<br>
            </div>
            <span style="font-size: 12vw; flex-shrink: 0; margin-left: 40px; margin-right: 40px">A-</span>
        </div>
        <div class="remark mark"
            style="background-color:black; width:100%; text-align:left; color:white; display:flex; align-items:center; justify-content:space-between; padding:10px;">
            <div style="flex: 1; padding-right: 20px;">
                <h3>Gli aspetti di Ingegneria del software (key points) che il caso di studio ha permesso di richiamare
                    o di introdurre nelle varie fasi ‘evolutive’ dei prototipi sviluppati durante la fase 2</h3>
                Durante questa fase, un aspetto che mi ha colpito particolarmente è stata la differenza tra
                documentazione tradizionale e modello eseguibile.<br>
                In molti contesti, l’analisi del problema si ferma a descrizioni testuali o diagrammi, spesso ambigui e
                difficili da verificare. Con QAK, invece, abbiamo prodotto modelli che non sono solo rappresentazioni,
                ma sono già software, pronti per essere eseguiti e osservati.<br>
                Questo approccio ha reso subito evidente se il comportamento del sistema era coerente con le attese,
                eliminando i passaggi (inevitabilmente ambigui, siamo esseri umani) tra analisi, progettazione ed
                implementazione.<br>
                Il fatto che il modello sia interpretabile dalla macchina garantisce chiarezza e verificabilità, e
                consente di lavorare più vicino al dominio del problema, senza perdersi nei dettagli tecnici
                prematuri.<br>
                Personalmente, ho trovato questo modo di procedere molto più efficace e diretto: permette di progettare
                pensando al comportamento, non solo alla struttura, e riduce i fraintendimenti tipici delle fasi
                iniziali.<br>
            </div>
            <span style="font-size: 12vw; flex-shrink: 0; margin-left: 40px; margin-right: 40px">B+</span>
        </div>
        <div class="remark mark"
            style="background-color:black; width:100%; text-align:left; color:white; display:flex; align-items:center; justify-content:space-between; padding:10px;">
            <div style="flex: 1; padding-right: 20px;">
                <h3>Opzionalmente: Il ruolo che lo scrivente ritiene abbia il concetto di linguaggio (di programmazione,
                    ma non solo) più volte evocato dal docente come esempio di un salto evolutivo fondamentale
                    dell’informatica rispetto al solo sviluppo di librerie</h3>
                Il parallelismo tra linguaggi naturali e linguaggi di programmazione è perfettamente valido.<br>
                Un linguaggio, che sia di programmazione o naturale, non si limita a fornire una forma per esprimere
                idee, ma gioca un ruolo fondamentale nel processo stesso di creazione e formulazione delle stesse.<br>
                Persone che conoscono linguaggi naturali diversi tendono a pensare in modo diverso proprio a causa della
                struttura e dei vocaboli a loro disposizione.<br>
                Imparare nuovi vocaboli non significa solo migliorare l’espressione, ma anche affinare la granularità
                con cui siamo in grado di cogliere le sfumature, e quindi di pensare criticamente.<br>
                Normalmente il linguaggio è il modo in cui pensiamo alle idee, ma per chiedersi in quale linguaggio è
                bene esprimere un'idee è necessaria un profonda familiarità con l'idea stessa.<br>
                Questo evidenzia quanto sia importante, ma anche complesso, sviluppare un linguaggio che soddisfi le
                esigenze specifiche di un determinato contesto.<br>
                Per quanto riguarda la differenza tra linguaggi e librerie invece; un linguaggio di programmazione è un
                sistema completo per descrivere algoritmi e strutture di controllo, mentre una libreria è un insieme di
                componenti già pronti, scritti in quel linguaggio, pensati per affrontare problemi specifici.<br>
                Le librerie estendono l'espressività del linguaggio in contesti concreti, ma non ne cambiano la
                natura.<br>
                Al contraria passare da un linguaggio ad un altro, specie se di derivazione diversa, può stravolgere
                completamente il paradigma, il modo di organizzare le idee e di procedere.<br>
                La scelta del linguaggio, in conclusione, è la scelta di mettere il primo piano alcuni aspetti,
                piuttosto che altri, rendendoli più semplici da cogliere ed esprimere.<br>
            </div>
            <span style="font-size: 12vw; flex-shrink: 0; margin-left: 40px; margin-right: 40px">S</span>
        </div>
</body>

</html>